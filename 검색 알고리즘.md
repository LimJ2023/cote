- 나에게 배열이 주어졌는데 어떤 사용자가 그 목록에 포함되어 있는지 확인하려면 어떻게 해야할까?

  - js의 indexOf()를 사용 -> 이것도 검색 알고리즘으로 작동

- 빅오 표기법의 O(log n)

  - 1,n,n^2은 생각하기 쉽다. 그러나 log는 조금 어려워
    log2(8) = 3 : 2의 몇승의 값이 8이 되나요? 라고 묻는 것.
    이러면 답은 3승. 몇제곱이냐를 묻는 것.
    빅오표기법에서 log2 === log 라고 여김.
    어떤 이진 로그를 계산하기 위해서는 그 숫자가 2로 나눴을 때 1보다 큰 횟수.
    중요한 것은 그래프에 어떻게 보이는가 전체적인 추세가 어떠한가.-> 시간 복잡도를 나타낼 때 쓴다.
    log n은 값이 커져도 기울기가 낮다.
    어떤 탐색 알고리즘은 로그 시간복잡도를 가지고 있다.

- 검색 알고리즘 종류

  1. 선형 검색 Linear Search

     - 배열을 모두 돌며 하나씩 확인하는 방법. -> 나쁜 접근법은 아니다. 그러나? 정렬되지 않은 배열이라면... 모두 돌아야하나?
     - 선형 검색 (indexOf,includes,find,findIndex) 은 모든 배열을 돌며 확인한다. Linear Search.
     - 빅오(O)표기법으로 생각하면 O(n).

  2. 이진 검색 Binary Search

     - 전제조건 : 데이터가 분류,정렬되어있어야 한다. (순서대로)
     - 검색할 때 배열의 중간점을 찾는다.-> 범위에 없는 나머지 절반은 무시한다 -> 다시 중간점을 찾는다. 반복..
     - 분할 정복 방식.
     - 빅오 표기법으로 생각하면 O(log n)
       - 16개의 요소가 있다면 4단계만에 완료.
       - 32개의 요소가 있다면? 5단계만에 완료.
       - log2(n) -> log(n)으로 나타냄.
       - " n의 크기를 2배로 늘릴 때마다 한 단계가 더 추가되면 log(n) "
     - 굉장히 좋은 알고리즘.

  3. 나이브 문자열 검색
     - 수도 코드 : 긴 문자열을 반복하는 루프문이 있고 함수는 긴 문자열과 패턴을 인자로 전달받아 긴 문자열의 각 문자를 반복
       짧은 문자열을 반복하는 루프도 하나 작성 그러고 나면 확인.
       문자가 일치하지 않으면 내부 루프에서 벗어남.
       짧은 문자열의 끝에 도달했다면 일치하는 문자열을 찾았다는 것.
