- 자료구조는 왜 배우는가?

  - 자료구조는 뭘 해주는걸까? -> 데이터를 저장할 때 특정한 패턴이 있다.. 자료를 저장하는 방법에 대한 이야기.

    - 왜 내가 이걸 배워야하지? : 고급 자료구조를 사용할 가능성이 많다.. 더 효율적인 무언가를(DB등..)
    - 각 자료구조는 특징이 있다..장점이 있다.

    - 쉬어가면서 하자. 자료구조는 충분히 시간을 두고 배우자.

- class

  - 객체들의 청사진.. 패턴을 정의하기 위해 사용할 것.
    - class Student{
      constructor(firstname,lastname) {
      this.firstname = firstname;
      this.lastname = lastname;
      }
      }

- 단일 연결 리스트

  - 연결리스트는 계단만 있는 건물과 같다... 각 층을 연결하는 노드만 존재
  - 인덱스가 없다. 헤드포인터,테일 존재. 각 노드는 next포인터로 연결.
  - 중간에 추가하거나 중간을 제거할 때 좋다.
  - 삽입과 제거에 효과적!
  - 빅오 : O(n) <- searching,removal,access; O(1) <-- insertion

- 이중 연결 리스트

  - 단일 연결 리스트와 비슷하나 앞과 뒤를 모두 가르키는 포인터를 가지고 있다.
  - 빅오 : O(1) <- insertion,Removal,searching; O(n) <- Access
  - 검색 기록 등....
  - 메모리적으로 더 많이 소비.

- 스택

  - 후입선출 <-설거지나 책이 쌓인 것을 생각...
  - undo/redo에도 씀...
  - 빅오 : O(n) <- insertion,removal. O(N) Searching,Access.

- 큐

  - 선입선출 <--- 토마토 정리를 생각... 줄서기를 생각
  - 빅오 : O(1) insertion, Removal. O(N) Searching, Access

- 트리

  - 트리란? 노드로 이루어진 데이터 구조인데 부모와 자식 관계가 있음. 일대다 관계...
  - 노드들은 각각 0개 이상의 노드를 가질 수 있음
  - 연결리스트도 어떻게 보면 트리인 것
  - 트리 노드는 형제를 가르킬 수 없다.
  - 출발점이 하나만 있어야 트리 구조이다.
  - 자식은 루트에서 멀어지는 노드들
  - 네트워크 라우팅도 트리 구조, 추상구문트리, 인공지능,머신러닝에도 사용. (최소최대 트리)
  - 폴더 설계도 트리 구조....json도 트리구조

  - bst:이진탐색트리
    - 부모 노드보다 왼쪽에 있는 자식 노드는 부모보다 작음. 오른쪽은 더 큼.
    - (데이터가 특정한 순서로 저장되어 있음)
    - 왜 이것들을 사용할까? : 무언가를 찾는게 매우 빠르기 때문. 비교할 때마다 찾아야 하는 요소가 절반으로
      줄어들기 때문에 O(logn)이라고 할 수 있을듯
    - 빅오 : O(logn) : insertion,Searching. "트리의 갯수가 2배가 될 때 단계는 1단계만 오름."

- 트리 순회

  - 트리의 모든 노드를 순회하려면 어떻게 해야 할까?
  - 4가지 순회 방법
  - 너비 우선,깊이 우선
  - BFS -> 옆으로 가로지르는 순회
  - DFS -> 아래로 내려가는 순회
  - 정위, 전위, 후위 순회...

  - 깊이우선과 너비 우선은 어떨 때 사용할까?

    - DFS : 넓게 펼쳐진 노드들일 경우 적합. (공간 복잡도의 문제.) 시간은 둘 다 같다.
    - BFS : 깊이가 깊을 경우 너비우선이 적합.
    - DFS의 순위 : 언제 전위,중위,후위를 사용할까....잘모름 그냥 알아두면 좋다.

  - 힙
    - 기본적으로 힙은 트리.
    - 최대 이진 힙에서 parent의 자식을 찾을 땐 2n + 1,2n + 2;
    - 반대로 부모를 찾을 땐 Math.fllor(1/2 (n-1));
    - 빅오 : O(log n) : insertion, remove
  - 우선 순위 큐

    - 각 요소가 그에 해당하는 우선순위를 가지는 데이터 구조
    - 힙과는 별개임 배열이나 리스트를 가지고도 만들 수 있다. 추상적 개념같은 것임...
    - 보통 낮은 숫자가 높은 우선순위다. (1순위 2순위...)

  - 해시 테이블

    - 키-밸류 의 쌍, 키는 순서를 가지지 않는다.
    - 찾기, 삽입, 빼기 속도가 빠름

  - 그래프
    - 노드나 노드들의 연결을 모아둔 것.
  - vertex: a node
  - 인접 행렬
    - a와b사이의 선 중첩 배열로 구현할 수 있음.
    - v가 정점의 숫자일 때 v^2의 공간을 차지함
    - edge를 확인하고 싶을 때 모든 edge에 대해 루프를 돌아서 찾아야함
    - 어떤 vertex의 정보를 확인하고 싶을 땐 매우 빠름.
  - 인접 리스트

    - vertex가 숫자를 가짐, 해시 테이블로 구현할 수도 있음.
    - 간선이 많지 않고 퍼져있는 그래프에 효과적(적은 공간 차지)
    - 배열 내에 실제 간선을 저장하고 있으므로 간선 확인에 효과적
    - 무언가를 찾는 것엔 느림

  - 그래프 순회
    - 방문, 최신화, 확인, 탐색 등....
    - 깊이 우선 탐색 DFS : 
